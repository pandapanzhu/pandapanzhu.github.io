---
layout: post
title: JAVA基础学习笔记--基础面试题总结
date:   2018-02-13 08:08:00 +0801
categories: document
tag: 教程
---

* content
{:toc}



# 写在最前

最近复习了一下Java的面试题，总结了一些初级JAVA面试的尿性，做了些笔记，现在把他PO出来。方便以后来看。


# Java 8大数据类型 

 | 类型 | byte | short | int | long | double | float | char | boolean
 | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
 | bit大小| 8 | 16 | 32 | 64 | 64 | 32 | 16 | 1 |
 | 字节大小| 1 | 2 | 3 | 8 | 8 | 4 | 2 | 1 |
 
 不同类型的变量在内存中分配的字节数不同，同时存储方式也是不同的。
 
 ## 数据存储原理
 
   **基本类型数据的存储原理：** 基本数据类型都不存在‘引用’的概念，基本数据类型都是直接存储在内存种的**内存栈**中，数据本身的值也是存储在栈空间的。
   **引用类型数据的存储原理：** 引用类型都继承与Object类，都是按照Java里面存储对象的内存模型进行数据存储的，使用堆栈搭配进行数据存储。“引用”是存储在有序的内存栈中，但是对象本身的值是存放在堆上的。

## “==”和Equals的区别

“==”比较的是内存地址是否相等，equals比较的是两个值是否相等。

来看看String的Equals方法源代码

    ```
        public boolean equals(Object anObject) {
            if (this == anObject) {
                return true;
            }
            if (anObject instanceof String) {
                String anotherString = (String)anObject;
                int n = value.length;
                if (n == anotherString.value.length) {
                    char v1[] = value;
                    char v2[] = anotherString.value;
                    int i = 0;
                    while (n-- != 0) {
                        if (v1[i] != v2[i])
                            return false;
                        i++;
                    }
                    return true;
                }
            }
            return false;
        }
    
    ```
从源代码我们可以看到，先判断两个对象再物理地址上是否相等，
然后比较两者的长度，再将字符串分割成一个一个的char类型数据，
因为char是基本数据类型，直接比较两个字符串的Unicode。

# 堆栈的区别 

## 栈

1. 栈空间由操作系统自动分配和释放
2. 基本数据类型时存放在栈中的
3. 声明的局部变量是存放在栈中的
4. 每个线程包含一个栈区，每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。
5. 栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。

## 堆

1.堆的空间需手动申请和释放 
2. 引用对象类型的值是存放在堆中的，但是其引用地址还是存放在栈中
3. 当我们new 一个对象的时候，该对象被分配到堆空间中。用完之后靠垃圾回收机制不定期自动消除。
4. 被final修饰的局部变量是存放在堆中的。


注（要考）：栈是一个线性的集合，按照后进先出的方法进行处理，存放的是基本数据类型和引用。
        jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身。

## 方法区
方法区又叫**静态区** ，跟堆一样，他也是被所有线程共享。方法区包含所有的class和static变量。
方法区中包含的都是在整个程序中永远唯一的元素

例子：

![堆栈示例](/styles/images/heapandstack/堆栈示例.jpg)

1. JVM执行main()函数，在栈内存中开辟一个空间，存放x变量（x变量是局部变量）。
   　　同时，在堆内存中也开辟一个空间，存放new int[3]数组，堆内存会自动内存首地址值，如0x0045。
   　　数组在栈内存中的地址值，会附给x，这样x也有地址值。所以，x就指向（引用）了这个数组。此时，所有元素均未附值，但都有默认初始化值0。
   
2. 在栈内存定义了新的数组变量内存y，同时将x的值0x0045附给了y。所以，y也指向了堆内存中的同一个数组。

3. 赋值 100 

4. 则变量x不再指向栈内存中的数组了。但是，变量y仍然指向，所以数组不消失。即，JVM的垃圾回收机制不会对其处理
    

重点 **要考** ：在JAVA8及以上的版本，
    基本数据类型的数组是引用到栈空间的，
    对象数据类型的数组引用在堆空间的。

因为基本类型数据的局部变量是存放在栈中，如果将该局部变量指向了数据的元素，则该元素的内存就在栈空间上。


# JVM 

既然说到了Java虚拟机，那就继续深入说说JVM里面的重点。

JVM 主要分为**5**个区域：

1. Java虚拟机栈

    该区域是线程私有的，每个线程不对该区域共享。
    每个方法在执行的时候都会创建一个栈帧，存储了局部变量表，操作数栈，动态链接和方法返回地址等。
    每个方法的调用和结束，就对应了一个栈帧的出栈和入栈。

2. 堆

    堆内存是线程共享的，在虚拟机启动或者new新的对象时，存放对应的对象实例。

3. 方法区

    方法区也是线程共享的，

4. 程序计数器

5. 本地方法栈




# TreeMap的实现原理

TreeMap继承于AbstractMap，实现了Cloneable接口，意味着它能被克隆。

TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n) 。
另外，TreeMap是非同步的。 它的iterator 方法返回的迭代器是fail-fastl的。

其结构是红黑二叉树，具有二叉树的所有特点，同时红黑树又是自平衡树，导致了TreeMap里面的数据呈**有序排列**。

**二叉树的基本特点（要考）**：树中的任何节点的值都要大于他的左节点小于他的右节点。

红黑二叉树的基本规则(要考)：
    
    1.每个节点都只能是红色或者黑色
    2. 根节点是黑色
    3. 每个叶节点或者空节点是黑色的
    4. 如果一个节点是红的，那他两个子节点必定是黑色的。
    5. 从任一节点到其每一个叶子节点的所有路径都包含相同的黑色节点。
    
其中TreeMap的基本实现图如下所示：

![TreeMap](/styles/images/java-map/TreeMapImplement.jpg)





# JDK8中的HashMap

HashMap 在 JDK8中又加入了红黑二叉树的模型，当链表的长度大于8时，就链表就转换成了红黑二叉树的形式。

同时加入了Node这个HashMap的内部类，Hash碰撞概率跟Node(哈希桶)的大小有关。

# 参考文档

[JAVA中分为基本数据类型及引用数据类型](https://www.cnblogs.com/dubo-/p/5565677.html)

[JAVA中的栈和堆举例](https://www.cnblogs.com/ibelieve618/p/6380328.html)

[关于Jvm知识看这一篇就够了](https://blog.csdn.net/lengyue309/article/details/79799752)